package scalajsbundler

import sbt._

import scalajsbundler.util.{Commands, JS}

object Webpack {

  /**
    * Copies the custom webpack configuration file and the webpackResources to the target dir
    *
    * @param targetDir target directory
    * @param webpackResources Resources to copy
    * @param customConfigFile User supplied config file
    * @return The copied config file.
    */
  def copyCustomWebpackConfigFiles(targetDir: File, webpackResources: Seq[File])(customConfigFile: File): File = {
    def copyToWorkingDir(targetDir: File)(file: File): File = {
      val copy = targetDir / file.name
      IO.copyFile(file, copy)
      copy
    }

    webpackResources.foreach(copyToWorkingDir(targetDir))
    copyToWorkingDir(targetDir)(customConfigFile)
  }

  /**
    * Writes the webpack configuration file
    *
    * @param emitSourceMaps Whether source maps is enabled at all
    * @param webpackEntryPoints Module entry points (name, file.js)
    * @param targetDir Directory to write the file into
    * @param log Logger
    * @return The written file
    */
  def writeConfigFile(
    emitSourceMaps: Boolean,
    webpackEntryPoints: Seq[(String, File)],
    targetDir: File,
    log: Logger
  ): File = {
    // Create scalajs.webpack.config.js
    val webpackConfigFile = targetDir / "scalajs.webpack.config.js" // TODO discriminate filename according to sjs stage
    val libName = "__scalajsbundler_deps__"
    val webpackConfigContent =
      JS.block(JS.`var`("webpack", Some(JS.ref("require").apply(JS.str("webpack")))),
      JS.ref("module").dot("exports").assign(JS.obj(Seq(
        "entry" -> JS.obj(webpackEntryPoints.map { case (key, file) =>
          key -> JS.arr(JS.str(file.absolutePath)) }: _*
        ),
        "output" -> JS.obj(
          "path" -> JS.str(targetDir.absolutePath),
          "filename" -> JS.str(libraryFileName("[name]")),
          "library" -> JS.str(libName)
        )
      ) ++ (
        if (emitSourceMaps) {
          val webpackNpmPackage = NpmPackage.getForModule(targetDir, "webpack")
          webpackNpmPackage.flatMap(_.major) match {
            case Some(1) =>
              Seq(
                "devtool" -> JS.str("source-map"),
                "module" -> JS.obj(
                  "preLoaders" -> JS.arr(
                    JS.obj(
                      "test" -> JS.regex("\\.js$"),
                      "loader" -> JS.str("source-map-loader")
                    )
                  )
                )
              )
            case Some(2) | Some(3) =>
              Seq(
                "devtool" -> JS.str("source-map"),
                "module" -> JS.obj(
                  "rules" -> JS.arr(
                    JS.obj(
                      "test" -> JS.regex("\\.js$"),
                      "enforce" -> JS.str("pre"),
                      "loader" -> JS.str("source-map-loader")
                    )
                  )
                )
              )
            case _ => sys.error("Unsupported webpack version")
          }
        } else Nil
        ): _*)))
    log.debug("Writing 'scalajs.webpack.config.js'")
    IO.write(webpackConfigFile, webpackConfigContent.show)

    webpackConfigFile
  }

  /**
    * Run webpack to bundle the application.
    *
    * @param generatedWebpackConfigFile Webpack config file generated by scalajs-bundler
    * @param customWebpackConfigFile User supplied config file
    * @param entries Module entries
    * @param targetDir Target directory (and working directory for Nodejs)
    * @param log Logger
    * @return The generated bundles
    */
  def libraries(
              generatedWebpackConfigFile: File,
              customWebpackConfigFile: Option[File],
              webpackResources: Seq[File],
              entryPointFiles: Seq[(String, File)],
              entries: Seq[(String, File)],
              targetDir: File,
              log: Logger
            ): Seq[File] = {

    val configFile = customWebpackConfigFile
      .map(Webpack.copyCustomWebpackConfigFiles(targetDir, webpackResources))
      .getOrElse(generatedWebpackConfigFile)

    log.info("Bundling the applications NPM dependencies")
    Webpack.run("--config", configFile.absolutePath)(targetDir, log)

    entries.map { case (k, v) =>  
      targetDir / Webpack.libraryFileName(k)
    }
  }
  
  val loaderScript: String =
    """
      |var exports = {};
      |var require = __scalajsbundler_deps__.require;
    """.stripMargin

  /**
    * Run webpack to bundle the application.
    *
    * @param targetDir Target directory (and working directory for Nodejs)
    * @param logger Logger
    * @return The generated bundles
    */
  def bundle(
    targetDir: File,
    scalaJsOutputFiles: Seq[(String, File)],
    webpackLibraryFiles: Seq[(String, File)],
    emitSourceMaps: Boolean = false,
    logger: Logger
  ): Seq[File] = 
    webpackLibraryFiles.flatMap { case (key, libraryFile) =>
      scalaJsOutputFiles.find(_._1 == key).map { scalaJsOutputFile =>
        (key, scalaJsOutputFile._2, libraryFile)
      }
    }.map { case (key, scalaJsOutputFile, libraryFile) =>
      val bundleFile = targetDir / Webpack.bundleFileName(key)
      val loaderFile = targetDir / Webpack.loaderFileName(key)

      if (emitSourceMaps) {
        logger.info("Bundling dependencies with source maps")
        IO.write(loaderFile, loaderScript)
        val concatContent =
          JS.let(
            JS.ref("require")(JS.str("concat-with-sourcemaps")),
            JS.ref("require")(JS.str("fs"))
          ) { (Concat, fs) =>
            JS.let(JS.`new`(Concat, JS.bool(true), JS.str(bundleFile.name), JS.str(";\n"))) { concat =>
              JS.block(
                concat.dot("add").apply(JS.str(libraryFile.absolutePath), 
                  fs.dot("readFileSync").apply(JS.str(libraryFile.absolutePath))),
                concat.dot("add").apply(JS.str(loaderFile.absolutePath), 
                  fs.dot("readFileSync").apply(JS.str(loaderFile.absolutePath))),
                concat.dot("add").apply(JS.str(scalaJsOutputFile.absolutePath), 
                  fs.dot("readFileSync").apply(JS.str(scalaJsOutputFile.absolutePath)), 
                  fs.dot("readFileSync").apply(JS.str(scalaJsOutputFile.absolutePath ++ ".map"), JS.str("utf-8"))),
                JS.let(JS.`new`(JS.ref("Buffer"), JS.str(s"\n//# sourceMappingURL=${bundleFile.name ++ ".map"}\n"))) { endBuffer =>
                  JS.let(JS.ref("Buffer").dot("concat").apply(JS.arr(concat.dot("content"), endBuffer))) { result =>
                    fs.dot("writeFileSync").apply(JS.str(bundleFile.absolutePath), result)
                  }
                },
                fs.dot("writeFileSync").apply(JS.str(bundleFile.absolutePath ++ ".map"), concat.dot("sourceMap"))
              )
            }
          }
        val concatFile = targetDir / "scalajsbundler-concat.js"
        IO.write(concatFile, concatContent.show)
        Commands.run(Seq("node", concatFile.absolutePath), targetDir, logger)
      } else {
        logger.info("Bundling dependencies without source maps")
        IO.withTemporaryFile("scalajs-bundler", key) { tmpFile =>
          IO.copyFile(libraryFile, tmpFile)
          IO.append(tmpFile, "\n")
          IO.append(tmpFile, "(function() {\n".stripMargin)
          IO.append(tmpFile, loaderScript)
          IO.append(tmpFile, "\n")
          IO.append(tmpFile, IO.readBytes(scalaJsOutputFile))
          IO.append(tmpFile, "})();")
          IO.move(tmpFile, bundleFile)
        }
      }
      bundleFile
    }

  /** Filename of the generated bundle, given its module entry name */
  def entryPointFileName(entry: String): String = s"$entry-entrypoint.js"
  
  /** Filename of the generated libraries bundle, given its module entry name */
  def libraryFileName(entry: String): String = s"$entry-libraries.js"
  
  /** Filename of the generated bundle, given its module entry name */
  def loaderFileName(entry: String): String = s"$entry-loader.js"
  
  /** Filename of the generated bundle, given its module entry name */
  def bundleFileName(entry: String): String = s"$entry-bundle.js"

  /**
    * Runs the webpack command.
    *
    * @param args Arguments to pass to the webpack command
    * @param workingDir Working directory in which the Nodejs will be run (where there is the `node_modules` subdirectory)
    * @param log Logger
    */
  def run(args: String*)(workingDir: File, log: Logger): Unit = {
    val webpackBin = workingDir / "node_modules" / "webpack" / "bin" / "webpack"
    val cmd = "node" +: webpackBin.absolutePath +: "--bail" +: args
    Commands.run(cmd, workingDir, log)
    ()
  }

}
